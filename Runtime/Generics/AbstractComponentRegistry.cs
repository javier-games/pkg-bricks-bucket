using System;
using System.Collections.Generic;
using UnityEngine;

// ReSharper disable MemberCanBeMadeStatic.Global
// ReSharper disable ReturnTypeCanBeEnumerable.Global
// ReSharper disable MemberCanBePrivate.Global
// ReSharper disable CollectionNeverUpdated.Global

namespace Monogum.BricksBucket.Core.Generics
{
	/// <!-- AbstractComponentRegistry -->
	/// <summary>
	/// Since iOS cannot support System.Reflection, AbstractReference has to
	/// have this static class to cast values.
	/// </summary>
	public abstract class AbstractComponentRegistry :
		IComponentRegistry, IAutogeneratedScript
	{

		#region Properties

		/// <inheritdoc cref="IAutogeneratedScript.NameSpace"/>
		public virtual string NameSpace => string.Empty;
		
		/// <inheritdoc cref="IAutogeneratedScript.Path"/>
		public virtual string Path => string.Empty;
		
		/// <inheritdoc cref="IAutogeneratedScript.ClassName"/>
		public virtual string ClassName => string.Empty;
		
		/// <inheritdoc cref="IAutogeneratedScript.Extension"/>
		public virtual string Extension => string.Empty;
		
		/// <summary>
		/// Collection of all registered types.
		/// </summary>
		protected virtual List<Type> ComponentTypesList { get; } =
			new List<Type>();

		/// <summary>
		/// Dictionary of actions to set values.
		/// </summary>
		protected virtual
			Dictionary<Type, Dictionary<string, Action<object, object>>> Set
		{
			get;
		}
			= new Dictionary<Type, Dictionary<string, Action<object, object>>
			>();

		/// <summary>
		/// Dictionary of functions to return values.
		/// </summary>
		protected virtual
			Dictionary<Type, Dictionary<string, Func<object, object>>> Get
		{
			get;
		}
			= new Dictionary<Type, Dictionary<string, Func<object, object>>>();
		
		/// <inheritdoc cref="IComponentRegistry.ComponentTypes"/>
		public IEnumerable<Type> ComponentTypes => ComponentTypesList;
		
		#endregion
		

		#region Methods

		/// <inheritdoc cref="IComponentRegistry.ContainsComponent"/>
		public bool ContainsComponent(Component component) =>
			Set.ContainsKey(component.GetType()) &&
			Get.ContainsKey(component.GetType());

		/// <inheritdoc cref="IComponentRegistry.ContainsProperty"/>
		public bool ContainsProperty(Component component, string property) =>
			Set[component.GetType()].ContainsKey(property) &&
			Get[component.GetType()].ContainsKey(property);

		/// <inheritdoc cref="IComponentRegistry.GetValue"/>
		public object GetValue(Component component, string property)
		{
			try
			{
				return Get[component.GetType()][property](component);
			}
			catch
			{
				// TODO: Add Feedback or Create TryGetValue.
				return null;
			}
		}

		/// <inheritdoc cref="IComponentRegistry.SetValue"/>
		public void SetValue(Component component, string property, object value)
		{
			try
			{
				Set[component.GetType()][property](component, value);
			}
			catch
			{
				// TODO: Add Feedback or Create TrySetValue.
			}
		}

		#endregion
	}
}