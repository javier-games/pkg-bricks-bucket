using System;
using System.Collections.Generic;
using Object = UnityEngine.Object;

// ReSharper disable MemberCanBeMadeStatic.Global
// ReSharper disable ReturnTypeCanBeEnumerable.Global
// ReSharper disable MemberCanBePrivate.Global
// ReSharper disable CollectionNeverUpdated.Global

namespace Monogum.BricksBucket.Core.Generics
{
	/// <!-- AbstractComponentRegistry -->
	/// <summary>
	/// Since iOS cannot support System.Reflection, AbstractReference has to
	/// have this static class to cast values.
	/// </summary>
	public abstract class AbstractComponentRegistry :
		IComponentRegistry, IAutogeneratedScript
	{

		#region Properties

		/// <inheritdoc cref="IAutogeneratedScript.NameSpace"/>
		public virtual string NameSpace => string.Empty;
		
		/// <inheritdoc cref="IAutogeneratedScript.Path"/>
		public virtual string Path => string.Empty;
		
		/// <inheritdoc cref="IAutogeneratedScript.ClassName"/>
		public virtual string ClassName => string.Empty;
		
		/// <inheritdoc cref="IAutogeneratedScript.Extension"/>
		public virtual string Extension => string.Empty;
		
		/// <summary>
		/// Collection of all registered types.
		/// </summary>
		protected virtual List<Type> ComponentTypesList { get; } =
			new List<Type>();

		/// <summary>
		/// Dictionary of actions to set values.
		/// </summary>
		protected virtual
			Dictionary<string, Dictionary<string, Action<object, object>>> Set
		{
			get;
		}
			= new Dictionary<string, Dictionary<string, Action<object, object>>
			>();

		/// <summary>
		/// Dictionary of functions to return values.
		/// </summary>
		protected virtual
			Dictionary<string, Dictionary<string, Func<object, object>>> Get
		{
			get;
		}
			= new Dictionary<string, Dictionary<string, Func<object, object>>>();
		
		/// <inheritdoc cref="IComponentRegistry.ComponentTypes"/>
		public IEnumerable<Type> ComponentTypes => ComponentTypesList;
		
		#endregion
		

		#region Methods

		/// <inheritdoc cref="IComponentRegistry.ContainsComponent"/>
		public bool ContainsComponent(Object component)
		{
			if (component == null)
			{
				return false;
			}
			
			var componentName = component.GetType().FullName;
			if (string.IsNullOrWhiteSpace(componentName))
			{
				return false;
			}
			
			return Set.ContainsKey(componentName) &&
			       Get.ContainsKey(componentName);
		}

		/// <inheritdoc cref="IComponentRegistry.ContainsProperty"/>
		public bool ContainsProperty(Object component, string property)
		{
			if (component == null)
			{
				return false;
			}
			
			var componentName = component.GetType().FullName;
			if (string.IsNullOrWhiteSpace(componentName))
			{
				return false;
			}
			
			return Set[componentName].ContainsKey(property) &&
				Get[componentName].ContainsKey(property);
		}

		/// <inheritdoc cref="IComponentRegistry.GetValue"/>
		public object GetValue(Object component, string property)
		{
			if (component == null)
			{
				return null;
			}
			
			var componentName = component.GetType().FullName;
			var valid =
				!string.IsNullOrWhiteSpace(componentName) &&
				ContainsComponent(component) &&
				ContainsProperty(component, property);
			
			return !valid ? null : Get[componentName][property](component);
		}

		/// <inheritdoc cref="IComponentRegistry.SetValue"/>
		public void SetValue(Object component, string property, object value)
		{
			if (component == null)
			{
				return;
			}
			
			var componentName = component.GetType().FullName;
			var valid =
				!string.IsNullOrWhiteSpace(componentName) &&
				ContainsComponent(component) &&
				ContainsProperty(component, property);

			if (!valid)
			{
				return;
			}
			
			Set[componentName][property](component, value);
		}

		#endregion
	}
}