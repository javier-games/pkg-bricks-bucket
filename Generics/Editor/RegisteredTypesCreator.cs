using System;
using System.IO;
using System.Reflection;
using System.Collections.Generic;

namespace Framework.Generics {

    #if UNITY_EDITOR
    /// <summary>
    /// Registered types creator.
    ///
    /// This script helps to register a new type in the RegisteredTypes.cs.
    /// By Javier García.
    /// </summary>
    public static class RegisteredTypesCreator {

        /// <summary> Writer for RegisteredTypes.cs </summary>
        private static StreamWriter writer;

        /// <summary> Registers a new type. </summary>
        /// <param name="type">Type.</param>
        public static void RegisterType (Type type) {


            //  Local Variables.
            List<Type> registeredTypes = new List<Type> ();
            PropertyInfo [] propertiesInfo = null;
            string localPath = string.Empty;
            string content = string.Empty;
            string subcontent = string.Empty;
            int propertiesToAdd = 0;
            int propertiesAdded = 0;


            //  Saving current types list.
            foreach (Type oldType in RegisteredTypes.Array) {
                registeredTypes.Add (oldType);
            }
            if (type != null && !registeredTypes.Contains (type))
                registeredTypes.Add (type);
            registeredTypes.Sort ((x, y) => string.Compare (
                x.FullName,
                y.FullName,
                StringComparison.CurrentCulture
            ));


            //  Initializing a new writer.
            if (writer != null)
                writer.Close ();
            writer = null;
            localPath = UnityEngine.Application.dataPath + "/Scripts/Framework/Generics/RegisteredTypes.cs";
            writer = new StreamWriter (localPath, false);


            #region Summary

            writer.WriteLine (System.String.Concat (
                "using System;",
                "\nusing System.Collections.Generic;",
                "\n",
                "\n/// <summary>",
                "\n/// Registered types.",
                "\n/// ",
                "\n/// Since iOS cannot support System.Reflection, DynRef has to",
                "\n/// have this static class to cast values.",
                "\n/// ",
                "\n/// ",
                "\n/// <autogenerated>",
                "\n/// ",
                "\n/// This code was generated by a tool.",
                "\n/// Changes to this file may cause incorrect behavior and will",
                "\n/// be lost if the code is regenerated.",
                "\n/// ",
                "\n/// </autogenerated>",
                "\n/// ",
                "\n/// ----------------------------------------------------------"
            ));
            writer.Write (System.String.Concat (
                "/// Code generated on ", string.Format ("{0:F}", DateTime.Now)
            ));
            writer.Write (System.String.Concat (
                "\n/// ----------------------------------------------------------",
                "\n///",
                "\n/// By Javier García.",
                "\n/// </summary>"
            ));

            #endregion


            //  Initializing Class
            writer.WriteLine ("\npublic static class RegisteredTypes {");


            #region Types List

            writer.WriteLine (System.String.Concat (
                "\n\t/// <summary> Quickly view of all registered types. </summary>",
                "\n\tprivate static readonly List<Type> typesList = new List<Type>{"
            ));
            content = string.Empty;
            for (int i = 0; i < registeredTypes.Count; i++) {
                content += System.String.Concat (
                    "\t\ttypeof(", registeredTypes [i].ToString (), ")"
                );
                if (i < registeredTypes.Count - 1)
                    content += ",\n";
            }
            writer.Write (System.String.Concat (content, "\n\t};"));

            #endregion


            #region Set Dictionary

            writer.WriteLine (System.String.Concat (
                "\n\n\t/// <summary> The set. </summary>",
                "\n\tprivate static readonly",
                "\n\tDictionary<string, Dictionary<string, Action<object, object>>> set =",
                "\n\t\tnew Dictionary<string, Dictionary<string, Action<object, object>>> {"
            ));
            content = string.Empty;
            for (int i = 0; i < registeredTypes.Count; i++) {

                subcontent = string.Empty;
                propertiesInfo = registeredTypes [i].GetProperties (
                    BindingFlags.Public | BindingFlags.Instance
                );
                propertiesToAdd = 0;
                foreach (PropertyInfo propertyInfo in propertiesInfo)
                    if (
                        propertyInfo.CanRead &&
                        propertyInfo.CanWrite &&
                        !propertyInfo.IsDefined (typeof (ObsoleteAttribute), true)
                    )
                        propertiesToAdd++;
                propertiesAdded = 0;

                //  Writing Properties.
                for (int j = 0; j < propertiesInfo.Length; j++) {
                    if (
                        propertiesInfo [j].CanRead &&
                        propertiesInfo [j].CanWrite &&
                        !propertiesInfo [j].IsDefined (typeof (ObsoleteAttribute), true)
                    ) {
                        subcontent += System.String.Concat (
                            "\n\t\t\t\t{\"",
                            propertiesInfo [j].Name,
                            "\", (component, value) => (component as ",
                            registeredTypes [i].ToString (),
                            ").",
                            propertiesInfo [j].Name,
                            " = (",
                            propertiesInfo [j].PropertyType,
                            ")value}"
                        );
                        propertiesAdded++;
                        if (propertiesAdded < propertiesToAdd)
                            subcontent += ",";
                    }
                }

                //  Writing Region Component.
                content += System.String.Concat (
                    "\t\t{",
                    "\n\t\t\t#region ", registeredTypes [i].ToString (),
                    "\n\t\t\t\"", registeredTypes [i].ToString (), "\",",
                    "\n\t\t\tnew Dictionary<string, Action<object, object>>{",
                    subcontent,
                    "\n\t\t\t}",
                    "\n\t\t\t#endregion",
                    "\n\t\t}"
                );
                if (i < registeredTypes.Count - 1)
                    content += ",\n";
            }
            writer.Write (System.String.Concat (content, "\n\t};"));

            #endregion


            #region Get Dictionary

            writer.WriteLine (System.String.Concat (
                "\n\n\t/// <summary> The get. </summary>",
                "\n\tprivate static readonly",
                "\n\tDictionary<string, Dictionary<string, Func<object, object>>> get =",
                "\n\t\tnew Dictionary<string, Dictionary<string, Func<object, object>>> {"
            ));

            content = string.Empty;
            for (int i = 0; i < registeredTypes.Count; i++) {

                subcontent = string.Empty;
                propertiesInfo = registeredTypes [i].GetProperties (
                    BindingFlags.Public | BindingFlags.Instance
                );
                propertiesToAdd = 0;
                foreach (PropertyInfo propertyInfo in propertiesInfo)
                    if (
                        propertyInfo.CanRead &&
                        propertyInfo.CanWrite &&
                        !propertyInfo.IsDefined (typeof (ObsoleteAttribute), true)
                    )
                        propertiesToAdd++;
                propertiesAdded = 0;

                //  Writing Properties.
                for (int j = 0; j < propertiesInfo.Length; j++) {
                    if (
                        propertiesInfo [j].CanRead &&
                        propertiesInfo [j].CanWrite &&
                        !propertiesInfo [j].IsDefined (typeof (ObsoleteAttribute), true)
                    ) {
                        subcontent += System.String.Concat (
                            "\n\t\t\t\t{\"",
                            propertiesInfo [j].Name,
                            "\", (component) => (component as ",
                            registeredTypes [i].ToString (),
                            ").",
                            propertiesInfo [j].Name,
                            "}"
                        );
                        propertiesAdded++;
                        if (propertiesAdded < propertiesToAdd)
                            subcontent += ",";
                    }
                }

                //  Writing Region Component.
                content += System.String.Concat (
                    "\t\t{",
                    "\n\t\t\t#region ", registeredTypes [i].ToString (),
                    "\n\t\t\t\"", registeredTypes [i].ToString (), "\",",
                    "\n\t\t\tnew Dictionary<string, Func<object, object>>{",
                    subcontent,
                    "\n\t\t\t}",
                    "\n\t\t\t#endregion",
                    "\n\t\t}"
                );
                if (i < registeredTypes.Count - 1)
                    content += ",\n";
            }
            writer.Write (System.String.Concat (content, "\n\t};"));

            #endregion


            #region Accessors and Methods

            writer.WriteLine (System.String.Concat (
                "\n\n\t/// <summary>  the array of types. </summary>",
                "\n\t/// <value>The array.</value>",
                "\n\tpublic static Type[] Array {",
                "\n\t\tget { return typesList.ToArray (); }",
                "\n\t}",
                "\n\t",
                "\n\t/// <summary> Containses the component. </summary>",
                "\n\t/// <returns><c>true</c>, if component was containsed.</returns>",
                "\n\t/// <param name=\"component\">Component.</param>",
                "\n\tpublic static bool ContainsComponent(string component){",
                "\n\t\treturn",
                "\n\t\tset.ContainsKey (component) &&",
                "\n\t\tget.ContainsKey (component);",
                "\n\t}",
                "\n\t",
                "\n\t/// <summary> Containses the property. </summary>",
                "\n\t/// <returns><c>true</c>, if property was containsed.</returns>",
                "\n\t/// <param name=\"component\">Component.</param>",
                "\n\t/// <param name=\"property\">Property name.</param>",
                "\n\tpublic static bool ContainsProperty(string component, string property) {",
                "\n\t\treturn",
                "\n\t\t\tset[component].ContainsKey (property) &&",
                "\n\t\t\tget[component].ContainsKey (property);",
                "\n\t}",
                "\n\t",
                "\n\t/// <summary> Gets the value. </summary>",
                "\n\t/// <returns>The value.</returns>",
                "\n\t/// <param name=\"component\">Component.</param>",
                "\n\t/// <param name=\"property\">Property name.</param>",
                "\n\tpublic static object GetValue(object component, string property) {",
                "\n\t\ttry {",
                "\n\t\t\treturn get[component.GetType ().ToString ()][property] (component);",
                "\n\t\t}",
                "\n\t\tcatch(Exception exception){",
                "\n\t\t\tUnityEngine.Debug.LogError (exception);",
                "\n\t\t\treturn null;",
                "\n\t\t}",
                "\n\t}",
                "\n\t",
                "\n\t/// <summary> Sets the value. </summary>",
                "\n\t/// <param name=\"component\">Component.</param>",
                "\n\t/// <param name=\"property\">Property name.</param>",
                "\n\t/// <param name=\"value\">Value.</param>",
                "\n\tpublic static void SetValue (object component, string property, object value) {",
                "\n\t\ttry {",
                "\n\t\t\tset[component.GetType ().ToString ()][property] (component, value);",
                "\n\t\t}",
                "\n\t\tcatch (Exception exception) {",
                "\n\t\t\tUnityEngine.Debug.LogError (exception);",
                "\n\t\t}",
                "\n\t}"
            ));
            #endregion


            //  End Class.
            writer.Write ("}");


            //  Closing writer.
            writer.Close ();
            writer = null;

            //  Recompiling assets.
            UnityEditor.AssetDatabase.Refresh ();
        }
    }
    #endif
}


// Original Script
/*
using System.Collections.Generic;
using System;

/// <summary>
/// Registered types.
///
/// Since iOS cannot support System.Reflection, DynRef has to had
/// this static class to cast values.
///
///
/// <autogenerated>
///
/// This code was generated by a tool.
/// Changes to this file may cause incorrect behavior and will be lost if
/// the code is regenerated.
///
/// </autogenerated>
///
/// ----------------------------------------------------------
/// Code generated on 2017-08-25T09:20:15.8886930-05:00
/// ----------------------------------------------------------
///
/// By Javier García.
/// </summary>
public static class RegisteredTypes {

    /// <summary> Quickly view of all registered types. </summary>
    private static readonly List<Type> typesList = new List<Type>{
        typeof(UnityEngine.Light)
    };

    /// <summary> The set. </summary>
    private static readonly
    Dictionary<string, Dictionary<string, Action<object, object>>> set =
        new Dictionary<string, Dictionary<string, Action<object, object>>> {
        {

            #region UnityEngine.Light

            "UnityEngine.Light",
            new Dictionary<string, Action<object, object>>{
                {"color", (component, value) => (component as UnityEngine.Light).color = (UnityEngine.Color)value }
            }

            #endregion
        }
    };

    /// <summary> The get. </summary>
    private static readonly
    Dictionary<string, Dictionary<string, Func<object, object>>> get =
        new Dictionary<string, Dictionary<string, Func<object, object>>> {
        {
            #region UnityEngine.Light

            "UnityEngine.Light",
            new Dictionary<string, Func<object, object>>{
                {"color", (component) => (component as UnityEngine.Light).color}
            }

            #endregion
        }
    };

    /// <summary>  the array of types. </summary>
    /// <value>The array.</value>
    public static Type[] Array {
        get { return typesList.ToArray (); }
    }

    /// <summary> Containses the component. </summary>
    /// <returns><c>true</c>, if component was containsed.</returns>
    /// <param name="component">Component.</param>
    public static bool ContainsComponent(string component){
        return
            set.ContainsKey (component) &&
            get.ContainsKey (component);
    }

    /// <summary> Containses the property. </summary>
    /// <returns><c>true</c>, if property was containsed.</returns>
    /// <param name="component">Component.</param>
    /// <param name="property">Property.</param>
    public static bool ContainsProperty(string component, string property) {
        return
            set[component].ContainsKey (property) &&
            get[component].ContainsKey (property);
    }

    /// <summary> Gets the value. </summary>
    /// <returns>The value.</returns>
    /// <param name="component">Component.</param>
    /// <param name="property">Property name.</param>
    public static object GetValue(object component, string property) {
        try {
            return get[component.GetType ().ToString ()][property] (component);
        }
        catch(Exception exception){
            UnityEngine.Debug.LogError (exception);
            return null;
        }
    }

    /// <summary> Sets the value. </summary>
    /// <param name="component">Component.</param>
    /// <param name="property">Property name.</param>
    /// <param name="value">Value.</param>
    public static void SetValue (object component, string property, object value) {
        try {
            set[component.GetType ().ToString ()][property] (component, value);
        }
        catch (Exception exception) {
            UnityEngine.Debug.LogError (exception);
        }
    }

}
*/
